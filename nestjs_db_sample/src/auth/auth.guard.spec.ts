import { UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from './auth.guard';
import { jwtConstants } from './constant';
import { authGuardMockFactory } from './auth.guard.mock';

describe('AuthGuard', () => {
  it('should be defined', () => {
    const authGuard = authGuardMockFactory();

    expect(authGuard).toBeDefined();
  });
  // Generated by CodiumAI
  // When a valid token is provided, the canActivate method should return true.
  it('should return true when a valid token is provided', async () => {
    const jwtServiceMock = {
      verifyAsync: jest.fn().mockResolvedValue({}),
    };
    const authGuard = new AuthGuard(jwtServiceMock as any);
    const context = {
      switchToHttp: jest.fn().mockReturnThis(),
      getRequest: jest
        .fn()
        .mockReturnValue({ headers: { authorization: 'Bearer validToken' } }),
    };

    const result = await authGuard.canActivate(context as any);

    expect(result).toBe(true);
    expect(jwtServiceMock.verifyAsync).toHaveBeenCalledWith('validToken', {
      secret: jwtConstants.secret,
    });
  });

  // When an invalid token is provided, the canActivate method should throw an UnauthorizedException.
  it('should throw UnauthorizedException when an invalid token is provided', async () => {
    const jwtServiceMock = {
      verifyAsync: jest.fn().mockRejectedValue(new Error()),
    };
    const authGuard = new AuthGuard(jwtServiceMock as any);
    const context = {
      switchToHttp: jest.fn().mockReturnThis(),
      getRequest: jest
        .fn()
        .mockReturnValue({ headers: { authorization: 'Bearer invalidToken' } }),
    };

    await expect(authGuard.canActivate(context as any)).rejects.toThrow(
      UnauthorizedException,
    );
    expect(jwtServiceMock.verifyAsync).toHaveBeenCalledWith('invalidToken', {
      secret: jwtConstants.secret,
    });
  });

  // When no token is provided, the canActivate method should throw an UnauthorizedException.
  it('should throw UnauthorizedException when no token is provided', async () => {
    const authGuard = new AuthGuard({} as any);
    const context = {
      switchToHttp: jest.fn().mockReturnThis(),
      getRequest: jest.fn().mockReturnValue({ headers: {} }),
    };

    await expect(authGuard.canActivate(context as any)).rejects.toThrow(
      UnauthorizedException,
    );
  });

  // When an expired token is provided, the canActivate method should throw an UnauthorizedException.
  it('should throw UnauthorizedException when an expired token is provided', async () => {
    const jwtServiceMock = {
      verifyAsync: jest.fn().mockRejectedValue({ name: 'TokenExpiredError' }),
    };
    const authGuard = new AuthGuard(jwtServiceMock as any);
    const context = {
      switchToHttp: jest.fn().mockReturnThis(),
      getRequest: jest
        .fn()
        .mockReturnValue({ headers: { authorization: 'Bearer expiredToken' } }),
    };

    await expect(authGuard.canActivate(context as any)).rejects.toThrow(
      UnauthorizedException,
    );
    expect(jwtServiceMock.verifyAsync).toHaveBeenCalledWith('expiredToken', {
      secret: jwtConstants.secret,
    });
  });

  // When an invalid secret is provided, the canActivate method should throw an UnauthorizedException.
  it('should throw UnauthorizedException when an invalid secret is provided', async () => {
    const jwtServiceMock = {
      verifyAsync: jest.fn().mockRejectedValue({ name: 'JsonWebTokenError' }),
    };
    const authGuard = new AuthGuard(jwtServiceMock as any);
    const context = {
      switchToHttp: jest.fn().mockReturnThis(),
      getRequest: jest
        .fn()
        .mockReturnValue({ headers: { authorization: 'Bearer token' } }),
    };

    await expect(authGuard.canActivate(context as any)).rejects.toThrow(
      UnauthorizedException,
    );
    expect(jwtServiceMock.verifyAsync).toHaveBeenCalledWith('token', {
      secret: jwtConstants.secret,
    });
  });

  // When an invalid token format is provided, the extractTokenFromHeader method should return undefined.
  it('should return undefined when an invalid token format is provided', () => {
    const authGuard = new AuthGuard({} as any);
    const request = { headers: { authorization: 'InvalidTokenFormat' } };

    const result = authGuard['extractTokenFromHeader'](request as any);

    expect(result).toBeUndefined();
  });
});
